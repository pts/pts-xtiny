#! /bin/sh
# by pts@fazekas.hu at Sun Oct 19 13:46:41 CEST 2014

""":" #xtiny: wrapper tool for creating tiny i386 executables

type python2.7 >/dev/null 2>&1 && exec python2.7 -- "$0" ${1+"$@"}
type python2.6 >/dev/null 2>&1 && exec python2.6 -- "$0" ${1+"$@"}
type python2.5 >/dev/null 2>&1 && exec python2.5 -- "$0" ${1+"$@"}
type python2.4 >/dev/null 2>&1 && exec python2.4 -- "$0" ${1+"$@"}
exec python -- ${1+"$@"}; exit 1

pts-xtiny is a collection of tools and a small and incomplete libc for
creating tiny (200-byte), statically linked ELF executables on Linux i386.

Instead of your regular `gcc ...' command, run `xtiny gcc ...'. Use
`#include <xtiny.h>' for some library (libc) functions. See
http://github.com/pts/pts-xtiny for more information.
"""

import os
import os.path
import pipes
import re
import stat
import subprocess
import sys


STDARG_DIR_RE = re.compile(r'"(/[^\n"]*)/stdarg[.]h"')


def find_compiler_include_dir(compiler, progdir):
  e_cmd = (compiler, '-m32', '-E', '%s/stdarginc.c' % progdir)
  try:
    p = subprocess.Popen(e_cmd, stdout=subprocess.PIPE)
  except (IOError, OSError), e:
    sys.stderr.write('fatal: Running %s failed: %s\n' % (compiler, e))
    sys.exit(3)
  try:
    data = p.stdout.read()
  finally:
    exit_code = p.wait()
  if exit_code:
    sys.stderr.write(
        'fatal: Running %s failed with code %d\n' % (compiler, exit_code))
    sys.exit(3)
  dirs = set(STDARG_DIR_RE.findall(data))
  if not dirs:
    sys.stderr.write('fatal: compiler include dir not found\n')
    sys.exit(3)
  if len(dirs) > 1:
    sys.stderr.write('fatal: multiple compiler include dirs found: %r\n' %
                      dirs)
    sys.exit(3)
  compiler_include_dir = iter(dirs).next()
  if not os.path.isdir(compiler_include_dir):
    sys.stderr.write('fatal: compiler include dir does not exist: %s\n' %
                      compiler_include_dir)
    sys.exit(3)
  return compiler_include_dir


def get_bdir_prog_path(compiler, bdir, prog):
  cmd = [compiler, '-m32']
  if bdir is not None:
    cmd.extend(('-B', bdir))
  cmd.extend(('-print-prog-name=%s' % prog,))
  try:
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  except (IOError, OSError), e:
    sys.stderr.write('fatal: Running %s failed: %s\n' % (compiler, e))
    sys.exit(4)
  try:
    data = p.stdout.read()
  finally:
    exit_code = p.wait()
  if exit_code:
    sys.stderr.write(
        'fatal: Running %s failed with code %d\n' % (compiler, exit_code))
    sys.exit(4)
  if len(data) < 2 or data.find('\n') != len(data) - 1:
    sys.stderr.write('fatal: prog %s name not found\n' % prog)
    sys.exit(4)
  return data[:-1]


def wrap_linker(argv, prgdir):
  """When xtiny is called as a linker as bdir/ld --xtiny-run-ld."""
  cmd = [None]
  argi = 1
  linkdirs = []
  is_verbose = False
  do_gc_sections = False
  has_custom_linker_script = False
  has_entry = False
  m_arg = None
  while argi < len(argv):
    arg = argv[argi]
    argi += 1
    if arg == '--xtiny-run-ld':
      # The parent xtiny has called us with `--xtiny-run-ld <ld-prog>'.
      if argi == len(argv):
        sys.stderr.write('fatal: missing arg for --xtiny-run-ld')
        sys.exit(1)
      is_found = True
      cmd[0] = argv[argi]
      subsequent_args = argv[argi + 1:]
      if '-T' in subsequent_args:
        has_custom_linker_script = True
      cmd.extend(subsequent_args)
      assert '-L---' not in cmd
      break
    elif arg == '--xtiny-ld-v':
      is_verbose = True
    elif arg.startswith('-l'):
      sys.stderr.write('fatal: library too early: %s\n' % arg)
      sys.exit(1)
    elif arg == '-L---':
      # Append -L... directories explicitly specified in the compiler cmdline,
      # and already saved to linkdirs.
      #
      # The linker command line typically has -Lexplicitly -L--- -L/system, and
      # we want to omit the -L/system.
      cmd[1 : 1] = linkdirs
      linkdirs = []
    elif arg.startswith('-L'):
      linkdirs.append(arg)
    elif arg == '--gc-sections':
      do_gc_sections = True
      cmd.append(arg)
    elif arg == '-T':
      # GNU ld expects -T after the .o and .a files, so we do it this late.
      sys.stderr.write('fatal: -T specified too early')
      sys.exit(2)
    elif arg in ('-e', '--entry') or arg.startswith('--entry='):
      has_entry = True
      cmd.append(arg)
    elif arg == '-m' and argi < len(argv):
      cmd.extend((arg, argv[argi]))
      m_arg = argv[argi]
      argi += 1
    else:
      cmd.append(arg)
  assert cmd[0] is not None, 'missing --xtiny-run-ld flag'
  relink_cmd = []
  to_remove_after_link = []
  if do_gc_sections and has_custom_linker_script:
    # GNU ld 2.24 doesn't support --gc-sections and -T together, so we do it
    # with 2 steps with -r.
    i = cmd.index('-T')
    linker_script = cmd[i + 1]
    cmd[i : i + 2] = []
    if not has_entry:
      cmd.extend(('-e', '_start'))
    cmd.append('-r')
    i, output_file_idx = 2, None
    while i < len(cmd):
      if cmd[i - 1] == '-o':
        output_file_idx = i
      i += 1
    if output_file_idx is None:
      output_file = 'a.out'
      # We could also use tempfile.mkstemp.
      ro_output_file = output_file + '.xtiny-r.o'
      cmd.extend(('-o', ro_output_file))
    else:
      output_file = cmd[output_file_idx]
      # We could also use tempfile.mkstemp.
      ro_output_file = output_file + '.xtiny-r.o'
      cmd[output_file_idx] = ro_output_file
    relink_cmd = [cmd[0]]
    if m_arg is not None:  # Example: -m elf_i386
      relink_cmd.extend(('-m', m_arg))
    relink_cmd.extend(('-o', output_file, ro_output_file))
    relink_cmd.extend(('-T', linker_script))
    to_remove_after_link = [ro_output_file]
  if is_verbose:
    sys.stderr.write('xtiny running linker: %s\n' % ' '.join(map(pipes.quote, cmd)))
  def exec_linker():
    try:
      os.execvp(cmd[0], cmd)
    except OSError, e:
      sys.stderr.write('fatal: exec of linker %s failed: %s\n' % (cmd[0], e))
      sys.exit(2)
  if not relink_cmd:
    exec_linker()
  def run_in_subprocess(exec_function):
    pid = os.fork()
    if not pid:  # Child.
      try:
        exec_function()
      finally:
        os._exit(125)
    pid2, status = os.waitpid(pid, 0)
    assert pid == pid2
    if status:  # cmd has failed.
      sys.exit((status >> 8) or status)
  try:
    run_in_subprocess(exec_linker)
    if is_verbose:
      sys.stderr.write('xtiny running relink: %s\n' % ' '.join(map(pipes.quote, relink_cmd)))
    def exec_relink():
      try:
        os.execvp(relink_cmd[0], relink_cmd)
      except OSError, e:
        sys.stderr.write('fatal: exec of relink linker %s failed: %s\n' % (relink_cmd[0], e))
        sys.exit(2)
    run_in_subprocess(exec_relink)
  finally:
    for filename in to_remove_after_link:
      try:
        os.remove(filename)
      except OSError:
        pass


def main(argv):
  if len(argv) < 2 or argv[1] == '--help':
    sys.stderr.write(
        'Usage: %s <gcc|g++|clang|clang++> [<compiler-arg>...]\n'
        'Invokes the C/C++ compiler with -static against the xtiny libc\n')
    sys.exit(1)
  prog = __file__
  try:
    while stat.S_ISLNK(os.lstat(prog).st_mode):
      prog = os.path.join(os.path.dirname(prog), os.readlink(prog))
      # TODO(pts): Collapse ..s in the path etc.
  except OSError, e:
    pass
  progdir = os.path.dirname(prog)
  if '--xtiny-run-ld' in argv[1:]:
    return wrap_linker(argv, progdir)
  compiler = argv[1]
  compiler_basename = os.path.basename(compiler)
  is_clang = 'clang' in compiler_basename
  is_verbose = False
  opt = None
  has_debug = False
  do_link = True
  args_kept = []
  has_nostdinc = False
  is_compiling = False
  is_preproc = False
  bdir = None
  do_xtiny_link = True
  do_xtiny_gc_sections = False
  do_xtiny_linker_script = None
  has_gc_sections = False

  argi = 2  # Skip xtiny (argv[0]) and the compiler.
  while argi < len(argv):
    arg = argv[argi]
    argi += 1
    if not arg.startswith('-'):
      ext = os.path.splitext(os.path.basename(arg))[1]
      if ext in ('.cc', '.cp', '.cxx', '.cpp', '.c++', '.C',  # C++.
                 '.c', '.i', '.ii', '.m', '.mi', '.mm', '.M', '.mii',
                 '.h', '.H', '.hp', '.hxx', '.hpp', '.HPP', '.h++', '.tcc',
                 '.s', '.S', '.sx'):
        is_compiling = True
    elif arg == '-v':
      is_verbose = True
    elif arg.startswith('-O'):
      opt = arg
      continue
    elif arg.startswith('-g'):
      has_debug = True
    elif arg == '-E':
      is_preproc = True
      do_link = False
    elif arg in ('-c', '-S', '-M', '-MM'):
      do_link = False
    elif arg.startswith('-B'):
      if arg == '-B':
        if argi < len(argv):
          bdir = argv[argi]
      else:
        bdir = arg[2:]
    elif (
        arg in ('--sysroot', '--gcc-toolchain', '-target', '-m64',
                '-sysld', '--sysld', '-p', '-pg', '-pie', '-fpic', '-fPIC',
                '-fpie', '-fPIE', '-shared', '-shared-libgcc',
                '-nostdinc++', '-m64') or
        # -target is Cland-specific.
        arg.startswith('--sysroot=') or
        arg.startswith('--gcc-toolchain=')):
      sys.stderr.write('fatal: unsupported xtiny flag: %s\n' % arg)
      sys.exit(1)
    elif arg == '-nostdinc':
      has_nostdinc = True
      continue
    elif arg == '-mxtiny-link':  # Specify only if debugging xtiny.
      # TODO(pts): How is this useful for debugging?
      do_xtiny_link = True
      continue
    elif arg == '-mno-xtiny-link':  # Specify only if debugging xtiny.
      # With -mno-xtiny-link gcc stills work, but the linker command-line
      # contains too many `-L' directories, so `-lm' would try to link
      # against the system libm.a.
      do_xtiny_link = False
      continue
    elif arg == '-mxtiny-linker-script':  # Specify only if debugging xtiny.
      do_xtiny_linker_script = True
      continue
    elif arg == '-mno-xtiny-linker-script':  # Specify only if debugging xtiny.
      do_xtiny_linker_script = False
      continue
    elif arg == '-mxtiny-gcs':
      do_xtiny_gc_sections = True
      continue
    elif arg == '-mno-xtiny-gcs':
      do_xtiny_gc_sections = False
      continue
    elif arg == '-Wl,--gc-sections':
      has_gc_sections = True
    elif arg in ('-static-libgcc', '-nostdlib', '-s', '-static',
                 '-m32'):
      continue
    args_kept.append(arg)
  if do_xtiny_linker_script is None:
    # We don't specify a custom linker script if debugging (i.e. -g) is
    # enabled, because gdb doesn't understand our custom stripped ELF. In
    # this case the normal ELF linker output (with `ld -static') will be
    # created, linking against the xtiny libc.
    #
    # There is no search path for linker scripts, even a relative path would
    # make ld look for only that name.
    #
    # `ld -T' must be specified after the actual .o and .a files.
    do_xtiny_linker_script = not has_debug
  if (do_xtiny_linker_script and
      (do_xtiny_gc_sections or has_gc_sections) and
      not do_xtiny_link):
    print >>sys.stderr, 'fatal: if you use -Wl,--gc-sections or -mxtiny-gcs, you need -mxtiny-link (default) or -mno-xtiny-linker-script'
    sys.exit(2)
  cmd = [compiler, '-m32']
  if is_compiling or is_preproc:
    # For detecting whether <xtiny.h> should be included.
    cmd.append('-D__XTINY__')
  if is_compiling:
    if is_clang:
      # To avoid this (which only appears with `clang -c' and `clang -S':
      # argument clang-3.3.bin: warning: argument unused during compilation: '-fno-ident'
      cmd.append('-Qunused-arguments')
    if opt is not None:
      cmd.append(opt)
    # Without this we get the following error compiling binutils 2.20.1:
    # chew.c:(.text+0x233f): undefined reference to `__stack_chk_fail'
    #
    # Please note that gdb doesn't need the frame pointer for debugging,
    # because it has the unwind tables.
    cmd.extend(('-fno-stack-protector', '-fomit-frame-pointer'))
    if not has_debug:  # CFI, .eh_frame .eh_frame_hdr
      # -fno-unwind-tables is the default, we just play it safe.
      cmd.extend(('-fno-unwind-tables', '-fno-asynchronous-unwind-tables',))
    if has_nostdinc:
      # This wipes out the include list for gcc, clang and pts-clang.
      # Ubuntu Lucid clang-3.0 doesn't respect `-nostdinc'.
      cmd.extend(('-nostdinc', '-isysroot', '/dev/null/noisysroot'))
      # TODO(pts): Try -nostdsysteminc -nobuiltininc for clang.
    else:
      # clang default order: -I, /usr/include, clang-include, gcc-include
      # pts-clang default order: -I, /usr-include, clang-include
      # gcc default order: -I, gcc-include, /usr/include
      # our default order: -I, xtiny-include, (gcc|clang)-include

      # Puts it in front of -isysroot.
      cmd.extend(('-isystem', '%s/include' % progdir))
      if is_clang:
        compiler_include_dir = find_compiler_include_dir(compiler, progdir)
        cmd.extend(('-nostdinc', '-isysroot', '/dev/null/noisysroot',
                    '-isystem', compiler_include_dir))
      else:  # GCC.
        # Remove /usr/include, but keep gcc-include. Don't use -nostdinc, that
        # would remove gcc-include as well.
        cmd.extend(('-isysroot', '%s/noisysroot' % progdir))
    if opt in (None, '-Os'):
      # -fno-ident prevents generating the .comment section by preventing
      # this in the generated .s file: .ident  "GCC: ..."
      cmd.extend(('-Os', '-fno-ident', '-falign-functions=1'))
      if not is_clang:  # Clang 3.4 doesn't have these.
        cmd.extend(('-mpreferred-stack-boundary=2',
                    '-falign-jumps=1', '-falign-loops=1'))
    if do_xtiny_gc_sections:
      cmd.extend(('-ffunction-sections', '-fdata-sections'))
  if do_link:
    # -s is not necessary here, it would be passed as `ld -s', but `ld -T'
    # with the linker script overrides that. We specigy -s anyway so that it
    # will work with linkers ignoring the -T flag (e.g. GNU gold).
    if not has_debug:
      cmd.extend(('-s',))
    # -static is passed to ld. Even without that linking .so files wouldn't
    # work (could not read symbols: File in wrong format). But specifying
    # -static improves the error message.
    #
    # -Wl,-z,norelro is not needed, it affects only dynamic executables, and
    # it will emit a PT_GNU_RELRO to the program headers.
    # http://www.airs.com/blog/archives/189
    #
    # Without -Wl,--build-id=none, a PT_NOTE (.note.gnu.build-id) would be
    # added to the program headers.
    #
    # -Wl,-N unifies the .text and .data (and .bss) sectons, making them both
    # rwx, and emitting a single PT_LOAD program header for them. This makes a
    # difference if do_xtiny_linker_script is false. This works with ld and
    # gold.
    cmd.extend(('-static', '-nostdlib', '-Wl,--build-id=none', '-Wl,-N'))
    if do_xtiny_gc_sections:
      cmd.append('-Wl,--gc-sections')
    if do_xtiny_link:
      ld_prog_path = get_bdir_prog_path(compiler, bdir, 'ld')
      if is_clang and ld_prog_path.endswith('/clangld32/ld'):
        # pts-clang. Append .bin to the compiler name, because the wrapper
        # binary rejects the -B flag.
        #
        # Please note that there is no problem for non-linking (e.g. -E, -c)
        # with the pts-clang wrapper, so we don't modify it.
        cmd[0] += '.bin'
        if do_xtiny_linker_script:
          # pts-clang uses the GNU gold linker, which ignores -T for the linker
          # script. Let's use the system ld instead.
          # TODO(pts): Use the built-in ld if available.
          ld_prog_path = 'ld'
      assert ',' not in ld_prog_path, ld_prog_path
      if is_verbose:
        cmd.append('-Wl,--xtiny-ld-v')
      # This must be appended last because of --xtiny-run-ld.
      cmd.extend(('-B', '%s/bdir' % progdir, '-Wl,--xtiny-run-ld',
                  '-Wl,' + ld_prog_path))
  cmd.extend(args_kept)
  if do_link:
    # This must be between the .c .o files and the linker script (-T).
    cmd.extend(('%s/lib__xtiny.a' % progdir,))
    if do_xtiny_link:
      cmd.extend(('-L---',))
  if do_link and do_xtiny_linker_script:
    # GNU ld expects -T after the .o and .a files, so we do it this late.
    cmd.extend(('-Wl,-T,%s/xtiny.scr' % progdir,))
  if is_verbose:
    sys.stderr.write('xtiny running compiler: %s\n' % ' '.join(map(pipes.quote, cmd)))
  try:
    os.execvp(cmd[0], cmd)
  except OSError, e:
    sys.stderr.write('fatal: exec of compiler %s failed: %s\n' % (cmd[0], e))
    sys.exit(2)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
