#! /usr/bin/python
# by pts@fazekas.hu at Sun Oct 19 13:46:41 CEST 2014
#
# TODO(pts): Add -lgcc for long long division etc.
# TODO(pts): Add lib directory for possible additional user libraries.
# TODO(pts): Auto-detect GNU gold and use the built-in linker if available.
#            Please note /usr/bin/ld vs /usr/bin/gold.
# TODO(pts): Enumerate sections:
#            https://refspecs.linuxfoundation.org/LSB_2.1.0/LSB-Core-generic/LSB-Core-generic/specialsections.html
# TODO(pts): How to use CONSTRUCTORS etc. in the linker script?
# TODO(pts): Add support for debugging with gdb. -g shouldn't remove symbols
#            etc., maybe shouldn't use the linker script.
# TODO(pts): Convert the xtiny tool from Python to .c.
# TODO(pts): Add C++ support, possibly for many kinds of initializers.
# TODO(pts): Make it work with clang: now segfault and large binary for
#            pts-clang, and bad string constants for regular clang.
#            clang-3.4.bin: error: unknown argument: '-mpreferred-stack-boundary=2'
#            clang-3.4.bin: error: unknown argument: '-falign-jumps=1'
#            clang-3.4.bin: error: unknown argument: '-falign-loops=1'
#            Linking with the linker script doesn't work, gets linked regularly, and the result is a segfault.
#            __builtin_strlen acts really strangely.
# TODO(pts): pts-clang bug: no include paths in -E -.
# TODO(pts): Use glibc's smart __extern_always_inline instead?
# TODO(pts): Does __builtin_memcpy get hardwired with gcc -O3?
# TODO(pts): Add proper C++ `const char*' overloads for strstr etc, like
#            glibc string.h
# TODO(pts): Why is gcc-4.4 tinyt.c two.c only 424 bytes, but with gcc-4.6 it's
#            436 bytes?
# TODO(pts): Import syscalls from libsys (syscall-only libc, 1999). There is
#            socketcall, but no individual calls. What about constness etc.
#            Maybe uclibc?
# TODO(pts): doc: What are the similar projects?
# TODO(pts): doc: -fno-ident
# TODO(pts): Why is `xtiny gcc -g' ... `strip' output so large?
#
# Sine xtiny.h is in an `-isystem' directory, to get warnings for it,
# compile it with: `-Werror -Wsystem-headers', in addition to the usual `-W
# -Wall -Wextra'.
#

import os
import os.path
import pipes
import re
import stat
import subprocess
import sys


STDARG_DIR_RE = re.compile(r'"(/[^\n"]*)/stdarg[.]h"')


def find_compiler_include_dir(compiler, progdir):
  e_cmd = (compiler, '-m32', '-E', '%s/stdarginc.c' % progdir)
  try:
    p = subprocess.Popen(e_cmd, stdout=subprocess.PIPE)
  except (IOError, OSError), e:
    sys.stderr.write('fatal: Running %s failed: %s\n' % (compiler, e))
    sys.exit(3)
  try:
    data = p.stdout.read()
  finally:
    exit_code = p.wait()
  if exit_code:
    sys.stderr.write(
        'fatal: Running %s failed with code %d\n' % (compiler, exit_code))
    sys.exit(3)
  dirs = set(STDARG_DIR_RE.findall(data))
  if not dirs:
    sys.stderr.write('fatal: compiler include dir not found\n')
    sys.exit(3)
  if len(dirs) > 1:
    sys.stderr.write('fatal: multiple compiler include dirs found: %r\n' %
                      dirs)
    sys.exit(3)
  compiler_include_dir = iter(dirs).next()
  if not os.path.isdir(compiler_include_dir):
    sys.stderr.write('fatal: compiler include dir does not exist: %s\n' %
                      compiler_include_dir)
    sys.exit(3)
  return compiler_include_dir


def get_bdir_prog_path(compiler, bdir, prog):
  cmd = [compiler, '-m32']
  if bdir is not None:
    cmd.extend(('-B', bdir))
  cmd.extend(('-print-prog-name=%s' % prog,))
  try:
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
  except (IOError, OSError), e:
    sys.stderr.write('fatal: Running %s failed: %s\n' % (compiler, e))
    sys.exit(4)
  try:
    data = p.stdout.read()
  finally:
    exit_code = p.wait()
  if exit_code:
    sys.stderr.write(
        'fatal: Running %s failed with code %d\n' % (compiler, exit_code))
    sys.exit(4)
  if len(data) < 2 or data.find('\n') != len(data) - 1:
    sys.stderr.write('fatal: prog %s name not found\n' % prog)
    sys.exit(4)
  return data[:-1]


def wrap_linker(argv, prgdir):
  """When xtiny is called as a linker as bdir/ld --xtiny-run-ld."""
  cmd = [None]
  argi = 1
  linkdirs = []
  is_verbose = False
  while argi < len(argv):
    arg = argv[argi]
    argi += 1
    if arg == '--xtiny-run-ld':
      # The parent xtiny has called us with `--xtiny-run-ld <ld-prog>'.
      if argi == len(argv):
        sys.stderr.write('fatal: missing arg for --xtiny-run-ld')
        sys.exit(1)
      is_found = True
      cmd[0] = argv[argi]
      cmd.extend(argv[argi + 1:])
      assert '-L---' not in cmd
      break
    elif arg == '--xtiny-ld-v':
      is_verbose = True
    elif arg.startswith('-l'):
      sys.stderr.write('fatal: library too early: %s\n' % arg)
      sys.exit(1)
    elif arg == '-L---':
      # Append -L... directories explicitly specified in the compiler cmdline.
      cmd[1 : 1] = linkdirs
      linkdirs = []
    elif arg.startswith('-L'):
      linkdirs.append(arg)
    else:
      cmd.append(arg)
  assert cmd[0] is not None, 'missing --xtiny-run-ld flag'
  if is_verbose:
    sys.stderr.write('xtiny running linker: %s\n' % ' '.join(map(pipes.quote, cmd)))
  try:
    os.execvp(cmd[0], cmd)
  except OSError, e:
    sys.stderr.write('fatal: Exec of linker %s failed: %s\n' % (cmd[0], e))
    sys.exit(2)


def main(argv):
  if len(argv) < 2 or argv[1] == '--help':
    sys.stderr.write(
        'Usage: %s <gcc|g++|clang|clang++> [<compiler-arg>...]\n'
        'Invokes the C/C++ compiler with -static against the xtiny libc\n')
    sys.exit(1)
  prog = __file__
  try:
    while stat.S_ISLNK(os.lstat(prog).st_mode):
      prog = os.path.join(os.path.dirname(prog), os.readlink(prog))
      # TODO(pts): Collapse ..s in the path etc.
  except OSError, e:
    pass
  progdir = os.path.dirname(prog)
  if '--xtiny-run-ld' in argv[1:]:
    return wrap_linker(argv, progdir)
  compiler = argv[1]
  compiler_basename = os.path.basename(compiler)
  is_clang = 'clang' in compiler_basename
  is_verbose = False
  opt = None
  has_debug = False
  do_link = True
  args_kept = []
  has_nostdinc = False
  is_compiling = False
  is_preproc = False
  bdir = None
  do_xtiny_link = True
  do_xtiny_gc_sections = False
  do_xtiny_linker_script = None
  has_gc_sections = False

  argi = 2  # Skip xtiny (argv[0]) and the compiler.
  while argi < len(argv):
    arg = argv[argi]
    argi += 1
    if not arg.startswith('-'):
      ext = os.path.splitext(os.path.basename(arg))[1]
      if ext in ('.cc', '.cp', '.cxx', '.cpp', '.c++', '.C',  # C++.
                 '.c', '.i', '.ii', '.m', '.mi', '.mm', '.M', '.mii',
                 '.h', '.H', '.hp', '.hxx', '.hpp', '.HPP', '.h++', '.tcc',
                 '.s', '.S', '.sx'):
        is_compiling = True
    elif arg == '-v':
      is_verbose = True
    elif arg.startswith('-O'):
      opt = arg
      continue
    elif arg.startswith('-g'):
      has_debug = True
    elif arg == '-E':
      is_preproc = True
      do_link = False
    elif arg in ('-c', '-S', '-M', '-MM'):
      do_link = False
    elif arg.startswith('-B'):
      if arg == '-B':
        if argi < len(argv):
          bdir = argv[argi]
      else:
        bdir = arg[2:]
    elif (
        arg in ('--sysroot', '--gcc-toolchain', '-target', '-m64',
                '-sysld', '--sysld', '-p', '-pg', '-pie', '-fpic', '-fPIC',
                '-fpie', '-fPIE', '-shared', '-shared-libgcc',
                '-nostdinc++', '-m64') or
        # -target is Cland-specific.
        arg.startswith('--sysroot=') or
        arg.startswith('--gcc-toolchain=')):
      sys.stderr.write('fatal: unsupported xtiny flag: %s\n' % arg)
      sys.exit(1)
    elif arg == '-nostdinc':
      has_nostdinc = True
      continue
    elif arg == '-mxtiny-link':  # Specify only if debugging xtiny.
      # TODO(pts): How is this useful for debugging.
      do_xtiny_link = True
      continue
    elif arg == '-mno-xtiny-link':  # Specify only if debugging xtiny.
      do_xtiny_link = False
      continue
    elif arg == '-mxtiny-linker-script':  # Specify only if debugging xtiny.
      do_xtiny_linker_script = True
      continue
    elif arg == '-mno-xtiny-linker-script':  # Specify only if debugging xtiny.
      do_xtiny_linker_script = False
      continue
    elif arg == '-mxtiny-gcs':
      do_xtiny_gc_sections = True
      continue
    elif arg == '-mno-xtiny-gcs':
      do_xtiny_gc_sections = False
      continue
    elif arg == '-Wl,--gc-sections':
      has_gc_sections = True
    elif arg in ('-static-libgcc', '-nostdlib', '-s', '-static',
                 '-m32'):
      continue
    args_kept.append(arg)
  if do_xtiny_linker_script is None:
    # We don't specify a custom linker script if debugging (i.e. -g) is
    # enabled, because gdb doesn't understand our custom stripped ELF. In
    # this case the normal ELF linker output (with `ld -static') will be
    # created, linking against the xtiny libc.
    #
    # There is no search path for linker scripts, even a relative path would
    # make ld look for only that name.
    #
    # `ld -T' must be specified after the actual .o and .a files.
    do_xtiny_linker_script = not has_debug
  if do_xtiny_linker_script and (do_xtiny_gc_sections or has_gc_sections):
    print >>sys.stderr, 'fatal: if you use -Wl,--gc-sections or -mxtiny-gcs, also specify -mno-xtiny-linker-script'
    sys.exit(2)
  cmd = [compiler, '-m32']
  if is_compiling or is_preproc:
    # For detecting whether <xtiny.h> should be included.
    cmd.append('-D__XTINY__')
  if is_compiling:
    if is_clang:
      # To avoid this (which only appears with `clang -c' and `clang -S':
      # argument clang-3.3.bin: warning: argument unused during compilation: '-fno-ident'
      cmd.append('-Qunused-arguments')
    if opt is not None:
      cmd.append(opt)
    # Without this we get the following error compiling binutils 2.20.1:
    # chew.c:(.text+0x233f): undefined reference to `__stack_chk_fail'
    #
    # Please note that gdb doesn't need the frame pointer for debugging,
    # because it has the unwind tables.
    cmd.extend(('-fno-stack-protector', '-fomit-frame-pointer'))
    if not has_debug:  # CFI, .eh_frame .eh_frame_hdr
      cmd.extend(('-fno-unwind-tables', '-fno-asynchronous-unwind-tables',))
    if has_nostdinc:
      # This wipes out the include list for gcc, clang and pts-clang.
      # Ubuntu Lucid clang-3.0 doesn't respect `-nostdinc'.
      cmd.extend(('-nostdinc', '-isysroot', '/dev/null/noisysroot'))
      # TODO(pts): Try -nostdsysteminc -nobuiltininc for clang.
    else:
      # clang default order: -I, /usr/include, clang-include, gcc-include
      # pts-clang default order: -I, /usr-include, clang-include
      # gcc default order: -I, gcc-include, /usr/include
      # our default order: -I, xtiny-include, (gcc|clang)-include

      # Puts it in front of -isysroot.
      cmd.extend(('-isystem', '%s/include' % progdir))
      if is_clang:
        compiler_include_dir = find_compiler_include_dir(compiler, progdir)
        cmd.extend(('-nostdinc', '-isysroot', '/dev/null/noisysroot',
                    '-isystem', compiler_include_dir))
      else:  # GCC.
        # Remove /usr/include, but keep gcc-include. Don't use -nostdinc, that
        # would remove gcc-include as well.
        cmd.extend(('-isysroot', '%s/noisysroot' % progdir))
    if opt in (None, '-Os'):
      cmd.extend(('-Os', '-fno-ident', '-falign-functions=1'))
      if not is_clang:  # Clang 3.4 doesn't have these.
        cmd.extend(('-mpreferred-stack-boundary=2',
                    '-falign-jumps=1', '-falign-loops=1'))
    if do_xtiny_gc_sections:
      cmd.extend(('-ffunction-sections', '-fdata-sections'))
  if do_link:
    # -s is not necessary here, it would be passed as `ld -s', but `ld -T'
    # with the linker script overrides that. We specigy -s anyway so that it
    # will work with linkers ignoring the -T flag (e.g. GNU gold).
    if not has_debug:
      cmd.extend(('-s',))
    # -static is passed to ld. Even without that linking .so files wouldn't
    # work (could not read symbols: File in wrong format). But specifying
    # -static improves the error message.
    cmd.extend(('-static', '-nostdlib', '-Wl,-z,norelro',
                '-Wl,--build-id=none'))
    if do_xtiny_gc_sections:
      cmd.append('-Wl,--gc-sections')
    # With do_xtiny_link gcc would still work, but the linker
    # command-line would contain too many `-L' directories, so `-lm' would try
    # to link against the system libm.a.
    if do_xtiny_link:
      ld_prog_path = get_bdir_prog_path(compiler, bdir, 'ld')
      if is_clang and ld_prog_path.endswith('/clangld32/ld'):
        # pts-clang. Append .bin to the compiler name, because the wrapper
        # binary rejects the -B flag.
        #
        # Please note that there is no problem for non-linking (e.g. -E, -c)
        # with the pts-clang wrapper, so we don't modify it.
        cmd[0] += '.bin'
        if do_xtiny_linker_script:
          # pts-clang uses the GNU gold linker, which ignores -T for the linker
          # script. Let's use the system ld instead.
          # TODO(pts): Use the built-in ld if available.
          ld_prog_path = 'ld'
      assert ',' not in ld_prog_path, ld_prog_path
      if is_verbose:
        cmd.append('-Wl,--xtiny-ld-v')
      # This must be appended last because of --xtiny-run-ld.
      cmd.extend(('-B', '%s/bdir' % progdir, '-Wl,--xtiny-run-ld',
                  '-Wl,' + ld_prog_path))
  cmd.extend(args_kept)
  if do_link:
    # This must be between the .c .o files and the linker script (-T).
    cmd.extend(('%s/lib__xtiny.a' % progdir,))
    if do_xtiny_linker_script:
      cmd.extend(('-Wl,-T,%s/xtiny.scr' % progdir,))
    if do_xtiny_link:
      cmd.extend(('-L---',))
  if is_verbose:
    sys.stderr.write('xtiny running compiler: %s\n' % ' '.join(map(pipes.quote, cmd)))
  try:
    os.execvp(cmd[0], cmd)
  except OSError, e:
    sys.stderr.write('fatal: Exec of compiler %s failed: %s\n' % (cmd[0], e))
    sys.exit(2)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
